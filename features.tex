\section{\Zoo features}
\label{sec:features}

In this section, we review the main features of \Zoo, starting with the most generic ones and then addressing those related to concurrency.

\subsection{Algebraic data types}

\Zoo is an untyped language but, to write interesting programs, it is convenient to work with abstractions like algebraic data types.
To simulate tuples, variants and records, we designed a machinery to define projections, constructors and record fields.

For example, one may define a list-like type with:

\begin{minted}{coq}
Notation "'Nil'" := (in_type "t" 0) (in custom zoo_tag).
Notation "'Cons'" := (in_type "t" 1) (in custom zoo_tag).

Definition map : val :=
  rec: "map" "fn" "t" =>
    match: "t" with
    | Nil =>
        §Nil
    | Cons "x" "t" =>
        let: "y" := "fn" "x" in
        ‘Cons( "y", "map" "fn" "t" )
    end.
\end{minted}

Similarly, one may define a record-like type with two mutable fields \texttt{f1} and \texttt{f2}:

\begin{minted}{coq}
Notation "'f1'" := (in_type "t" 0) (in custom zoo_field).
Notation "'f2'" := (in_type "t" 1) (in custom zoo_field).

Definition swap : val :=
  fun: "t" =>
    "t" <-{f1} "t".{f2} ;; "t" <-{f2} "t".{f1}.
\end{minted}

\subsection{Mutually recursive functions}

\Zoo supports non-recursive ($\texttt{fun:}\ x_1 \dots x_n\ \texttt{=>}\ e$) and recursive ($\texttt{rec:}\ f\ x_1 \dots x_n\ \texttt{=>}\ e$) functions but only \emph{toplevel} mutually recursive functions.
Indeed, it is non-trivial to properly handle mutual recursion: when applying a mutually recursive function, a naive approach would replace the recursive functions by their respective bodies, but this typically makes the resulting expression unreadable.
To prevent it, the mutually recursive functions have to know one another so as to replace by the names instead of the bodies.
We simulate this using some boilerplate that can be generated by \texttt{ocaml2zoo}.
For instance, one may define two mutually recursive functions \texttt{f} and \texttt{g} as follows:

\begin{minted}{coq}
Definition f_g := (
  recs: "f" "x" => "g" "x"
  and: "g" "x" => "f" "x"
)%zoo_recs.
Definition f := ValRecs 0 f_g.
Definition g := ValRecs 1 f_g.
Instance : AsValRecs' f 0 f_g [f;g]. Proof. done. Qed.
Instance : AsValRecs' g 1 f_g [f;g]. Proof. done. Qed.
\end{minted}

\subsection{Standard library}

To save users from reinventing the wheel, we provide a standard library---more or less a subset of the \OCaml standard library.
Currently, it mainly includes standard data structures like: array (\mintinline{ocaml}{Array}), resizable array (\mintinline{ocaml}{Dynarray}), list (\mintinline{ocaml}{List}), stack (\mintinline{ocaml}{Stack}), queue (\mintinline{ocaml}{Queue}), double-ended queue, mutex (\mintinline{ocaml}{Mutex}), condition variable (\mintinline{ocaml}{Condition}).

\subsection{Physical equality}

\subsection{Structural equality}

\subsection{Concurrent primitives}

\Zoo supports concurrent primitives both on atomic references (from \mintinline{ocaml}{Atomic}) and atomic record fields (from \mintinline{ocaml}{Atomic.Loc}\footnote{The \mintinline{ocaml}{Atomic.Loc} module is part of the \href{https://github.com/ocaml/ocaml/pull/13404}{PR} that implements atomic record fields.}) according to the table below.
The \OCaml expressions listed in the left-hand column translate into the \Zoo expressions in the right-hand column.
Notice that an atomic location \mintinline[escapeinside=||]{ocaml}{[%atomic.loc |$e$|.|$f$|]} (of type \mintinline{ocaml}{_ Atomic.Loc.t}) translates directly into $e \texttt{.[} f \texttt{]}$.

\begin{center}
\begin{tabular}{ll}
    \OCaml &
    \Zoo
  \\ \hline
    \mintinline[escapeinside=||]{ocaml}{Atomic.get |$e$|} &
    $\texttt{!} e$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.set |$e_1$| |$e_2$|} &
    $e_1\ \texttt{<-}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.exchange |$e_1$| |$e_2$|} &
    $\texttt{Xchg}\ e_1 \texttt{.[contents]}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.compare_and_set |$e_1$| |$e_2$| |$e_3$|} &
    $\texttt{CAS}\ e_1 \texttt{.[contents]}\ e_2\ e_3$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.fetch_and_add |$e_1$| |$e_2$|} &
    $\texttt{FAA}\ e_1 \texttt{.[contents]}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.Loc.exchange [%atomic.loc |$e_1$|.|$f$|] |$e_2$|} &
    $\texttt{Xchg}\ e_1 \texttt{.[} f \texttt{]}\ e_2$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.Loc.compare_and_set [%atomic.loc |$e_1$|.|$f$|] |$e_2$| |$e_3$|} &
    $\texttt{CAS}\ e_1 \texttt{.[} f \texttt{]}\ e_2\ e_3$
  \\
    \mintinline[escapeinside=||]{ocaml}{Atomic.Loc.fetch_and_add [%atomic.loc |$e_1$|.|$f$|] |$e_2$|} &
    $\texttt{FAA}\ e_1 \texttt{.[} f \texttt{]}\ e_2$
\end{tabular}
\end{center}

One important aspect of this translation is that atomic accesses (\mintinline{ocaml}{Atomic.get} and \mintinline{ocaml}{Atomic.set}) correspond to plain loads and stores.
This is because we are working in a sequentially consistent memory model: there is no difference between atomic and non-atomic memory locations.

\subsection{Prophecy variables}

Lockfree algorithms exhibit complex behaviors.
To tackle them, \Iris provides powerful mechanisms such as \emph{prophecy variables}~\cite{DBLP:journals/pacmpl/JungLPRTDJ20}.
Essentially, prophecy variables can be used to predict the future of the program execution and reason about it.
They are key to handle \emph{future-dependent linearization points}: linearization points that may or may not occur at a given location in the code depending on a future observation.

\Zoo supports prophecy variables through the \texttt{Proph} and \texttt{Resolve} expressions---as in \HeapLang, the canonical \Iris language.
In \OCaml, these expressions correspond to \mintinline{ocaml}{Zoo.proph} and \mintinline{ocaml}{Zoo.resolve}, that are recognized by \texttt{ocaml2zoo}.
