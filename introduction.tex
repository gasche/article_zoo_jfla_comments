\section{Introduction}
\label{sec:introduction}

Designing concurrent algorithms, in particular \href{https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom}{\emph{lock-free}} algorithms, is a notoriously difficult task.
In this paper, we are concerned with proving the correctness of these algorithms.
The question of performance is also crucial and requires special expertise; we will not address it here.

% Gabriel: I think that you could say a bit more. My understanding is that you aim to verify programs written by concurrency experts, that we can assume are optimized for performance. Saying that you will "not address performance" could be understood as saying that performance is orthogonal to verification (which is not completely true, as performance needs dictate the language features you support), or that you are verifying slow/naive algorithms because you focus on correctness with no regard to performance.

\input{figures/stack}

\paragraph{Example 1: physical equality.}

Consider, for example, the \OCaml implementation of a concurrent stack~\cite{thomas1986systems} in \cref{fig:stack}.
Essentially, it consists of an atomic reference to a list that is updated atomically using the \mintinline{ocaml}{Atomic.compare_and_set} primitive.
While this simple implementation---it is indeed one of the simplest lockfree algorithms---may seem easy to verify, it is actually more subtle than it looks.

Indeed, the semantics of \mintinline{ocaml}{Atomic.compare_and_set} involves \emph{physical equality}: if the content of the atomic reference is physically equal to the expected value, it is atomically updated to the new value.
Comparing physical equality is tricky and can be dangerous---this is why \emph{structural equality} is often preferred---because the programmer has few guarantees about the \emph{physical identity} of a value.
In particular, the physical identity of a list, or more generally of an inhabitant of an algebraic data type, is not really specified.
The only guarantee is: if two values are physically equal, they are also structurally equal.
Apparently, we don't learn anything interesting when two values are physically distinct.
Going back to our example, this is fortunately not an issue, since we always retry the operation when \mintinline{ocaml}{Atomic.compare_and_set} returns \mintinline{ocaml}{false}.

Looking at the standard runtime representation of \OCaml values, this makes sense.
The empty list is represented by a constant while a non-empty list is represented by pointer to a tagged memory block.
Physical equality for non-empty lists is just pointer comparison.
It is clear that two pointers being distinct does not imply the pointed memory blocks are.

From the viewpoint of formal verification, this means we have to carefully design the semantics of the language to be able to reason about physical equality and other subtleties of concurrent programs.
Essentially, the conclusion we can draw is that the semantics of physical equality and therefore \mintinline{ocaml}{Atomic.compare_and_set} is non-deterministic: we cannot determine the result of physical comparison just by looking at the abstract values.

% Whether this is non-deterministic depends on the language you consider or its operational semantics. If you work at the level of source expressions, substituting variable names by their structural content, then indeed it is non-deterministic. But if you have locations as first-class values in your semantics to talk about allocations (which is what I would naively expect for a languagea modeling physical equality) then one can give deterministic computation rules for physical equality, right? Maybe it would make sense to say that it is "non-deterministic at the source level", for example?

\input{figures/rcfd}

\paragraph{Example 2: when physical identity matters.}

Consider another example given in \cref{fig:rcfd}: the \mintinline{ocaml}{Rcfd.close}\footnote{\url{https://github.com/ocaml-multicore/eio/blob/main/lib_eio/unix/rcfd.ml}} function from the \Eio~\cite{eio} library.
Essentially, it consists in protecting a file descriptor using reference counting.
Similarly, it relies on atomically updating the \mintinline{ocaml}{state} field using \mintinline{ocaml}{Atomic.Loc.compare_and_set}\footnote{Here, we make use of atomic record fields that were \href{https://github.com/ocaml/ocaml/pull/13404}{recently introduced} in \OCaml.}.
However, there is a complication.
Indeed, we claim that the correctness of \mintinline{ocaml}{close} derives from the fact that the \mintinline{ocaml}{Open} state does not change throughout the lifetime of the data structure; it can be replaced by a \mintinline{ocaml}{Closing} state but never by another \mintinline{ocaml}{Open}.
In other words, we want to say that 1) this \mintinline{ocaml}{Open} is \emph{physically unique} and 2) \mintinline{ocaml}{Atomic.Loc.compare_and_set} therefore detects whether the data structure has flipped into the \mintinline{ocaml}{Closing} state.
In fact, this kind of property appears frequently in lockfree algorithms; it also occurs in the \Kcas~\cite{kcas} library\footnote{\url{https://github.com/ocaml-multicore/kcas/blob/main/doc/gkmz-with-read-only-cmp-ops.md}}.

% This argument is a bit subtle and I'm not sure it is easy to follow from what you wrote. The point, as I understand it, is in the previous example it may look like (x == y implies x=y) is the only specification we require to reason about physical equality, in other words, it is okay if it returns "false" more often than expected. But in the present example you need the guarantee that when (x != Open foo), then indeed x is not (Open foo) itself: a semantics that only guarantees (x == y implies x=y) is not enough to prove this program correct, you need guarantees on when physical equality *does* hold.

Once again, this argument requires special care in the semantics of physical equality.
In short, we have to reveal something about the physical identity of some abstract values.
Yet, we cannot reveal too much---in particular, we cannot simply convert an abstract value to a concrete one (a memory location)---, since the \OCaml compiler may perform optimizations like sharing of immutable values and hash-consing.

% [Gabriel]: sharing immutable constants is something that we already do. Hash-consing is not something the compiler does (and will ever do), more like a thought experiment in what should remain allowed by a more precise semantics. I wish the formulation would treat them differently. For example: "the OCaml compiler performs optimziations like sharing of immutable constants, and a more precise semantics should remain compatible with adding other optimizations later on, such as forms of hash-consing"

\paragraph{A formalized \OCaml fragment for the verification of concurrent algorithms.}

These subtle aspects, illustrated through two realistic examples, justify the need for a faithful formal semantics of a fragment of \OCaml tailored for the verification of concurrent algorithms.
Ideally, of course, this fragment would include most of the language.
However, the direct practical aim of this work---the verification of real-life libraries like \Saturn~\cite{saturn}---led us to the following design philosophy: only include what is actually needed to express and reason about concurrent algorithms in a convenient way.

In this paper, we show how we have designed a practical framework, \Zoo, following this guideline.
We review the works related to the verification of \OCaml programs in \cref{sec:related}; we describe our framework in \cref{sec:zoo}; we detail the important features, including the treatment of physical equality, in \cref{sec:features} before concluding.
